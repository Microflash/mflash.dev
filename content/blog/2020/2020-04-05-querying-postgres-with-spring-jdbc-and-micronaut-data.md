---
title: 'Querying Postgres with Spring JDBC and Micronaut Data'
date: 2020-04-05 16:29:09
authors: [naiyer]
labels: [spring, micronaut, postgres]
---

`Repository` API of Spring Data is one of the most elegant and compelling features of Spring framework. The only caveat is that it works with JPA which brings an ORM (like Hibernate) into the equation. What if you don't want to use JPA but still need the flexibility of the Repository pattern? In this post, we'll learn how to use [Micronaut Data](https://micronaut-projects.github.io/micronaut-data/latest/guide/) which provides an implementation of the `Repository` compatible with Spring Data, without requiring an ORM.

Micronaut Data is one of the projects under [Micronaut](https://micronaut.io/) framework. It provides database toolkit that 
- doesn't use reflection or proxies, 
- generates the code at compile-time, and 
- provides compile-time type checks to ensure the repository methods fail early when incorrectly implemented

It works with multiple backends (including JPA and JDBC), provide a traditional synchronous API as well as reactive APIs for RxJava and Project Reactor, and integrates nicely with Spring Data and Spring Data JPA.

##### Setup

The examples in this post use

- Java 14
- Spring Boot 2.2.6
- Micronaut Data 1.0.2
- Postgres 12.2
- [Pagila Postgres sample database](https://github.com/devrimgunduz/pagila)
- Gradle 6.3

You can spin an instance of Postgres using the following `Compose` file.

```yaml
version: "3.1"

services:
  db:
    image: postgres:12.2-alpine
    container_name: postgres_12.2
    ports:
      - 5432:5432
    environment:
      POSTGRES_PASSWORD: example
```

Execute the following command to launch the container.

```bash
docker-compose up -d
```

Import Pagila sample database. We'll query the `actor` table using Micronaut Data.

## Configure the project

Generate a Spring Boot project with [Spring Initializr](https://start.spring.io/), and add `spring-boot-starter-web`, `spring-boot-starter-data-jdbc` and `postgresql` as dependencies.

To use Micronaut Data and persistence annotations, add `micronaut-data-spring` and `jakarta.persistence-api` respectively, as dependencies.

Your `build.gradle` would look like this.

```groovy{16-22}
plugins {
  id 'org.springframework.boot' version '2.2.6.RELEASE'
  id 'io.spring.dependency-management' version '1.0.9.RELEASE'
  id 'java'
}

group = 'dev.mflash.guides'
version = '0.0.1'
sourceCompatibility = JavaVersion.VERSION_14

repositories {
  jcenter()
}

dependencies {
  implementation('org.springframework.boot:spring-boot-starter-web')
  implementation('org.springframework.boot:spring-boot-starter-data-jdbc')
  implementation('io.micronaut.data:micronaut-data-spring:1.0.2') {
    exclude(group: 'org.hibernate')
  }
  implementation('jakarta.persistence:jakarta.persistence-api')
  runtimeOnly('org.postgresql:postgresql')
  testImplementation('org.springframework.boot:spring-boot-starter-test') {
    exclude(group: 'org.junit.vintage', module: 'junit-vintage-engine')
  }
}

test {
  useJUnitPlatform()
}
```

Open `application.yml` file and add the following database configuration for Spring.

```yaml
# src/main/resources/application.yml

spring:
  datasource:
    platform: postgres
    url: jdbc:postgresql://localhost:5432/pagila
    username: postgres
    password: example
```

## Define the domain

Create an entity for `actor`.

```java
// src/main/java/dev/mflash/guides/pagila/domain/Actor.java

public class Actor {

  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private @Id int actorId;
  private String firstName;
  private String lastName;
  private OffsetDateTime lastUpdate;

  // constructors, getters, setters, etc.
}
```

The `actorId` field is of type `SERIAL` which Postgres autoincrements on every new record. That's why we're delegating the id generation to Postgres with `GenerationType.IDENTITY` strategy.

## Create a repository

Define an `ActorRepository` interface and add the following code.

```java
// src/main/java/dev/mflash/guides/pagila/repository/ActorRepository.java

public interface ActorRepository extends CrudRepository<Actor, Integer> {

  Set<Actor> findAll();

  @Query("SELECT * FROM Actor a WHERE a.last_name = :lastName")
  Set<Actor> findByLastName(String lastName);

}
```

This is your run-of-the-mill Spring `Repository` with a method `findAll` to fetch all the actor records, and another method `findByLastName` which executes a query to fetch the actors with specified last name.

The implementation of this repository will be generated by Micronaut Data *at compile-time*, as opposed to Spring Data which generates them at runtime.

## Implement the service and controller

Implement an `ActorService` as follows to fetch the data from `ActorRepository` and pass it to `ActorController`.

```java
// src/main/java/dev/mflash/guides/pagila/service/ActorService.java

public @Service class ActorService {

  private final ActorRepository repository;

  public ActorService(ActorRepository repository) {
    this.repository = repository;
  }

  public Set<Actor> getAllActors() {
    return repository.findAll();
  }

  public Set<Actor> getByLastName(String lastName) {
    return repository.findByLastName(lastName.toUpperCase());
  }
}
```

Finally, create an `ActorController` to expose the endpoints through which the service can be called.

```java
// src/main/java/dev/mflash/guides/pagila/controller/ActorController.java

@RequestMapping("/actor")
public @RestController class ActorController {

  private final ActorService actorService;

  public ActorController(ActorService actorService) {
    this.actorService = actorService;
  }

  @GetMapping
  public Set<Actor> getAllActors() {
    return actorService.getAllActors();
  }

  @GetMapping("/{lastName}")
  public Set<Actor> getByLastName(@PathVariable String lastName) {
    return actorService.getByLastName(lastName);
  }
}
```

Start the application by launching the `Launcher`.

```java
// src/main/java/dev/mflash/guides/pagila/Launcher.java

public @SpringBootApplication class Launcher {

  public static void main(String[] args) {
    SpringApplication.run(Launcher.class, args);
  }
}
```

You'll get the following error.

```bash
org.springframework.core.convert.ConverterNotFoundException: No converter found capable of converting from type [java.sql.Timestamp] to type [java.time.OffsetDateTime]
```

This happens because Spring cannot figure out how to convert the `Actor`'s `lastUpdate` field which is of Postgres `timestampz` datatype into Java's `OffsetDateTime` type.

### Converters for `OffsetDateTime`

Extend Spring's `Converter` interface to define a `TimestampToOffsetDateTimeConverter` that converts a `Timestamp` type to `OffsetDateTime` type.

```java
// src/main/java/dev/mflash/guides/pagila/configuration/TimestampToOffsetDateTimeConverter.java

public class TimestampToOffsetDateTimeConverter implements Converter<Timestamp, OffsetDateTime> {

  public @Override OffsetDateTime convert(Timestamp source) {
    return source.toInstant().atOffset(ZoneOffset.UTC);
  }
}
```

> **Note** that Postgres writes the records of type `timestampz` with UTC timezone. You'll have to adjust the timezone offset, if required by your application. For this example, we'll leave it to UTC.

Similarly, write an `OffsetDateTimeToTimestampConverter` that converts a `OffsetDateTime` type to `Timestamp` type.

```java
// src/main/java/dev/mflash/guides/pagila/configuration/OffsetDateTimeToTimestampConverter.java

public class OffsetDateTimeToTimestampConverter implements Converter<OffsetDateTime, Timestamp> {

  public @Override Timestamp convert(OffsetDateTime source) {
    return Timestamp.from(Instant.from(source));
  }
}
```

Inject these converters through a configuration.

```java
// src/main/java/dev/mflash/guides/pagila/configuration/DatabaseConfiguration.java

@EnableJdbcRepositories(basePackages = "dev.mflash.guides.pagila.repository")
public @Configuration class DatabaseConfiguration {

  @Primary
  public @Bean JdbcCustomConversions customConversions() {
    final var converters = new ArrayList<Converter<?, ?>>();
    converters.add(new TimestampToOffsetDateTimeConverter());
    converters.add(new OffsetDateTimeToTimestampConverter());
    return new JdbcCustomConversions(converters);
  }
}
```

You'll have to mark this bean as `@Primary` to avoid conflict with the default `JdbcCustomConversions` bean injected by the `JdbcRepositoriesAutoConfiguration`.

Now, you'll be able to run the application successfully.

Use the following REST requests to verify if the application works as expected.

```bash
curl --location --request GET 'http://localhost:8080/actor'
curl --location --request GET 'http://localhost:8080/actor/WAHLBERG'
```

## References

**Source Code** &mdash; [spring-jdbc-micronaut-data](https://gitlab.com/mflash/spring-guides/-/tree/master/spring-jdbc-micronaut-data)

**See also**
- [Micronaut Data](https://micronaut-projects.github.io/micronaut-data/latest/guide/)
- [Pagila Postgres sample database](https://github.com/devrimgunduz/pagila)